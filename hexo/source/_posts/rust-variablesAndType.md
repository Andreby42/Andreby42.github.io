---
title: rust-variablesAndType
date: 2019-08-02 00:03:18
tags: [Rust]
categories: [Rust]

---

变量与类型<!--more-->

* rust变量必须先声明后使用，所有的变量必须初始化

  ` let varibales:i32=42`

* rust中声明的变量默认是只读的 如果想要变量是可写的即可改变的

  ```
  let mut y=5;
   y=6;
  ```

* 变量遮蔽，相同名称变量 后面的变量会将前面的变量这笔起来，当我们想复用一个变量名的时候就很有用，可以通过变量遮蔽实现不同类型的变量的重新绑定

  ````
  fn main(){
   let x="hello";
   println!("{}"，x);
   //下面的x将上面的x进行遮蔽 如果没有let 那么下面的声明就是对x的重新赋值
   let x=6;
   println!("{}",x);
  }
  ````

  ```
  fn main(){
   let mut v= Vec::new();
   
   v.push(1);
   
   //从这里往下v成了只读变量 可读写变量v已经被遮蔽了,同样 如果一个不可变变量 也可以通过变量遮蔽将其变为 //可变变量
   let v=v;
   println!("{}",v);
  }
  ```

* 类型推导,rust可以从变量生命的语句中获取信息进行类型推导，还可以通过上下文进行推导

  自动类型推导和动态类型系统是两码事，rust是静态类型语言即 **一个变量的类型必须在编译阶段就确定，且无法改变，只是在某些时候不需要在源码中显式写出来而已**

* 类型别名

  可以使用type关键字 给同一个类型其别名（type alias）

  ```
  type Age =u32;
  
  fn grow(age:Age ,year:u32){
  	age+year;
  }
  ```

* 静态变量

  rust使用static关键字进行声明静态变量，rust中唯一的声明全局变量的方法

  ```
  static GLOBAL_COUNTER:i32=0	
  ```

  * 全局变量必须在声明的时候马上初始化
  * 全局变量的初始化必须是编译期可以确定的常量，不能包括执行期才能确定的表达式或语句或函数调用
  * 带有mut修饰的全局变量 在使用的时候必须使用unsafe关键字

  ```
  static mut COUNTER_2:i32=3;
  
  unsafe{
  	COUNTER_2=6;
  	println!("{}"，COUNTER);
  }
  ```

* 常量

  使用const关键字生命常量

  常量是常量，故不能使用mut进行修饰

  ```
  const GLOBAL：i32=12;
  ```

* bool基本数据类型

  & | 与&& ||

  ```
  fn man(){
  	let x=true;
  	let y:bool=false;
  }
  ```

* char 类型

  可以描述任何一个符合unicode标准的字符值在代码中单个字符字面量使用单引号进行包围,占据的空间是4个字节。对一ASCII字符其实只需要占用一个字节，rust中可以使用一个字母b在字符或字符串前表示这个字面量存储在u8类型数组中，这样占用空间比char类型的数组要小一些

  ```
  let love ='a';
  let x:u8=1;
  let y:u8=b'A';
  ```

* 整数类型

  rust中的数字类型分为整数类型与浮点数类型，各种整数类型之间的主要区分特征是：有符号/无符号及占据空间大小

  **如果一个变量是有符号的那么他的最高位的那个bit就是符号位，表示该数为正值还是负值。如果一个变量是无符号类型，那么他的最高位和其他位一样表示该数的大小。**

  如一个byte(8bit)的数据来说，如果存的是无符号数，那么它的表达范围是0-255,如果存的是有符号数，那么表达的范围是-128-127。

  isize与usize在不同的系统上的占据的空间不一致

* 浮点类型

  按占据空间大小分 分f32与f64

* 指针类型

  * Box<T> 指向类型T 拥有所有权 可以释放内存
  * &T 指向T类型的借用指针，也称引用，无权释放内存 无权修改写数据
  * & mut T 指向类型T的mut 借用指针 无权释放内存，可以修改数据
  * *const T 指向T类型 的只读裸指针 没有生命周期信息 无权修改数据
  * ×mut T 指向类型T的可读写裸指针 没有生命周期 可以写数据

*  类型转换

  使用as进行类型间的转换注意只适用与合理的类型转换。

* 复合类型

  * tuple
  * struct
  * enum
  * tuple struct

* 类型递归定义 

  rust允许递归定义

  直接嵌套是不行的，那么使用指针进行间接引用就好了

  ```
  struct Recursive{
  	data:i32
  	rec:Box<Recursive>
  }
  ```

  
