---
title: 限流防止重复提交
date: 2018-09-29 21:48:46
tags: [Web]
categories: [限流]
---

限流防止重复提交了解下<!--more-->

#### JAVA做限流

在之前的开发中，由于网络等各种原因出现了app端多次提交的情况，这里牵扯到了一个接口的幂等性的问题，同事使用了redis来做限流，防止重复提交。

记录下。以后用的上。两种方式，一种用map去做，一种用redis去做

* 定义一个注解

  ```
  package com.convergence.support;
  
  import java.lang.annotation.Documented;
  import java.lang.annotation.ElementType;
  import java.lang.annotation.Retention;
  import java.lang.annotation.RetentionPolicy;
  import java.lang.annotation.Target;
  
  import org.springframework.core.Ordered;
  import org.springframework.core.annotation.Order;
  
  @Retention(RetentionPolicy.RUNTIME)
  @Target(ElementType.METHOD)
  @Documented
  @Order(Ordered.HIGHEST_PRECEDENCE)
  public @interface RequestLimit {
  	  /**
       * 允许访问的次数，默认值MAX_VALUE
       */
      int count() default Integer.MAX_VALUE;
  
      /**
       * 时间段，单位为毫秒，默认值一分钟
       */
      long time() default 60000;
  
  }
  ```

* redis的方式

  * 定义切面类。进行切面操作

    ```
    package com.convergence.support.aop;
    
    import java.util.concurrent.TimeUnit;
    
    import javax.servlet.http.HttpServletRequest;
    
    import org.aspectj.lang.JoinPoint;
    import org.aspectj.lang.annotation.Aspect;
    import org.aspectj.lang.annotation.Before;
    import org.slf4j.Logger;
    import org.slf4j.LoggerFactory;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.data.redis.core.RedisTemplate;
    import org.springframework.web.context.request.RequestContextHolder;
    import org.springframework.web.context.request.ServletRequestAttributes;
    
    import com.convergence.support.RequestLimit;
    import com.convergence.support.RequestLimitException;
    import com.convergence.support.util.IpUtil;
    @Aspect
    public class RequestLimitAop {
    	private static final Logger logger = LoggerFactory.getLogger(RequestLimitAop.class);
    	@Autowired
    	private RedisTemplate redisTemplate;
    
    	@Before("within(@org.springframework.stereotype.Controller *) && @annotation(limit)")
    	public void requestLimit(JoinPoint joinPoint, RequestLimit limit) throws RequestLimitException {
    		try {
    			Object[] args = joinPoint.getArgs();
    			HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.currentRequestAttributes())
    					.getRequest();
    			String ipAddress = IpUtil.getIpAddress(request);
    			String url = request.getRequestURL().toString();
    			String key = "req_limit_".concat(url).concat("_").concat(ipAddress);
    			boolean checkResult = checkWithRedis(limit, key);
    			if (!checkResult) {
    				logger.debug("requestLimited," + "[用户ip:{}],[访问地址:{}]超过了限定的次数[{}]次", ipAddress, url, limit.count());
    				throw new RequestLimitException();
    			}
    		} catch (RequestLimitException e) {
    			throw e;
    		}
    
    	}
    
    	private boolean checkWithRedis(RequestLimit limit, String key) {
    		long count = redisTemplate.opsForValue().increment(key, 1);
    		if (count == 1) {
    			redisTemplate.expire(key, limit.time(), TimeUnit.MILLISECONDS);
    		}
    		if (count > limit.count()) {
    			return false;
    		}
    		return true;
    	}
    }
    
    ```

  * aop配置 在com.convergence.support.aop下

    ```
    package com.muse.config;
    
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.ComponentScan;
    import org.springframework.context.annotation.Configuration;
    import org.springframework.context.annotation.EnableAspectJAutoProxy;
    
    import com.muse.support.aop.RequestLimitAop;
    
    /**
     * 开启aop 配合自定义注解 RequestLimitAop。
     * 
     * @author andreby
     *
     */
    @Configuration
    @EnableAspectJAutoProxy
    @ComponentScan(basePackages = { "com.convergence.support.aop" })
    public class AopConfig {
    	@Bean
    	public RequestLimitAop requestLimitAop() {
    		return new RequestLimitAop();
    	}
    }
    
    
    ```

  * 异常类定义

    ```
    package com.convergence.support;
    /**
     * 限流异常类
     * @author andreby
     *
     */
    public class RequestLimitException extends Exception {
    
    	/**
    	 * 
    	 */
    	private static final long serialVersionUID = 1L;
    
    	public RequestLimitException() {
    		super("HTTP请求超出设定的限制");
    	}
    
    	@Override
    	public StackTraceElement[] getStackTrace() {
    		return super.getStackTrace();
    	}
    
    }
    
    ```

  * 进行controller的访问控制

    ```
    package com.convergence.web.admin;
    
    import javax.servlet.http.HttpServletRequest;
    
    import org.springframework.stereotype.Controller;
    import org.springframework.web.bind.annotation.RequestMapping;
    import org.springframework.web.bind.annotation.ResponseBody;
    
    import com.convergence.support.RequestLimit;
    
    @RequestMapping("/aop")
    @Controller
    public class AopController {
    
    	@RequestMapping(value = "/test")
    	@RequestLimit(count = 2)
    	@ResponseBody
    	public String requestLimit(HttpServletRequest request) {
    		return "test";
    	}
    
    }
    ```


#### Nginx做限流

nginx提供两种限流方式，一种是控制速率 一种是控制并发连接数

* 控制速率

  * 正常限流

    ngx_http_limit_req_module模块提供限制请求处理速率能力，使用了漏桶算法（leaky bucket），

    下面的例子使用nginx_limit_req_zone和limit_req两个指令，限制单个ip的请求处理速率

    在nginx.conf http中添加限流配置：

    格式 ：limit_req_zone key zone rate

  ```
  http{
        limit_req_zone $binary_remote_addr zone=myRateLimit:10m rate=10r/s;
     }
  ```

  配置server，使用limit_req指令应用限流：

  ```
  server{
      location / {
          limit_req zone=myRateLimit;
          proxy_pass http://my_upstream;
      }
  }
  ```

  * **key：** 定义限流对象，binary_remote_addr 是一种key，表示基于remote_addr（客户端IP）来做限流，

    binary_的目的是压缩内存占用量。

  * **zone**:定义共享内存区来存储访问信息，myRateLimit:10m 表示一个大小为10M，名字为myRateLimit的内存区域，1M能存储16000IP地址的访问信息，10M可以存储16Wip地址访问信息。**

  * **rate** 用于设置最大访问速率，rate=10r/s表示每秒最多处理10个请求，Nginx实际上以毫秒为粒度来跟踪请求信息，因此10r/s实际上是限制：每100毫秒处理一个请求。这意味着，自上一个请求处理完后，若后续100毫秒内又有请求到达，将拒绝处理该请求。

* 处理突发流量

  上面例子限制10r/s，如果有时正常流量突然增大，超出的请求将被拒绝，无法处理突发流量。可以结合burst参数使用来解决问题

  ```
  server{
      location / {
          limit_req zone=myRateLimit burst=20;
          proxy_pass http://my_upstream;
      }
   }
  ```

  burst可以理解为突发或者爆发，表示在超过设定的处理速率后能额外处理的请求数。当rate=10r/s时，将1s拆为10份，即每100ms可处理1个请求。

  此外 burst=20,表示若同时有21个请求到达，Nginx会处理第一个请求，剩余20个请求将放入队列中，然后每隔100ms从队列中获取一个请求进行处理。若请求数大于21，将拒绝处理多余的请求，直接返回503.

  不过，单独使用burst参数并不实用，假设burst=50,rate依然为10r/s，排队中的50个请求虽然每100ms会处理一个，但第50个请求却需要等待50*100ms即5s

  因此 burst常常与nodelay一起使用：

  ```
  server{
      location /{
          limit_req zone=myRateLimit burst=20 nodelay;
          proxy_pass http://my_upstream;
      }
  }
  ```

  **nodelay**针对的是burst参数，**burst=20 nodelay ** 表示这20个请求立马处理，不能延迟，相当于特事特办，不过即使这20个突发请求立马处理结束，后续来了请求也不会立马处理。burst=20 相当于缓存队列中占2-个坑，即使请求被处理了，这20个位置也只能按100ms一个来释放。

* 限制链接数

  nginx_http_limit_conn_module提供了限制链接数的能力，利用**limit_conn_zone和limit_conn **两个指令。

  下面是官方例子：

  ```
  limit_conn_zone $binary_remote_addr zone=perip:10m;
  limit_conn_zone $server_name zone=perserver:10m;
  server{
      ...
      limit_conn perip 10;
      limit_conn perserver 100;
  }
  ```

  **limit_conn perip 10 **作用的key是$binary_remote_addr,表示限制单个ip同时最多能持有10个链接。

  **limit_conn perserver 100**作用的key是$server_name,表示虚拟主机（server）同时能处理并发链接的总数。

  **需要注意的是**：只有当**request header** 被后端server处理后，这个链接才进行计数。

* 设置白名单

  限流主要针对外部访问，内网访问相对安全，可以不做限流，通过设置白名单即可，那么可以利用

  nginx_http_geo_module和ngx_http_map_module两个工具模块来搞定。

  在nginx.conf的http部分中进行配置白名单：

  ```
  geo $limit{
      default 1;
      10.0.0.0/8 0；
      192.168.0.0/24 0;
      172.20.0.35 0;
  }
  map $limit $limit_key{
      0 "";
      1 $binary_remote_addr;
  }
  limit_req_zone $limit_key zone=myRateLimit:10m rate=10r/s;
  ```

  **geo**对于白名单（子网或ip都可以）将返回0，其他ip返回1；

  **map**将$limit转换为**$limit_key**,如果是**$limit**是0（白名单），则返回空字符串，如果是1，则返回客户端实际ip

  **limit_req_zone**限流的key不再使用**$binary_remote_addr**，而是使用**$limit_key**来动态获取值。如果是白名单，limit_req_zone的限流key则为空字符串，**将不会限流**；若不是白名单，将会对客户端真实ip进行限流。

* 限制数据传输速度能力即下载速度

  使用**nginx_http_core_module**来实现。

  ```
  location /flv/{
      flv；
      limit_rate_after 20m;
      limit_rate 100k;
  }
  ```

  这个限制是针对每个请求的，表示客户端下载前20M时不限速，后续限制100KB/S

  []: https://toutiao.io/k/r9wf3f	"Nginx的两种限流方式"

  **TODO:JAVA map实现限流。**